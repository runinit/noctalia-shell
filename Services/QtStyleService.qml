pragma Singleton

import QtQuick
import Quickshell
import Quickshell.Io

import qs.Commons

Singleton {
  id: root

  // Available Qt styles
  property ListModel availableQtStyles: ListModel {}

  // Current Qt style
  property string currentQtStyle: Settings.data.appearance ? Settings.data.appearance.qtStyle : "Fusion"

  // Common Qt styles that should be available
  readonly property var commonStyles: [
    { name: "Fusion", description: "Modern cross-platform style" },
    { name: "Windows", description: "Windows-like appearance" },
    { name: "Breeze", description: "KDE Plasma style" },
    { name: "kvantum", description: "Kvantum theme engine" },
    { name: "qt5ct-style", description: "qt5ct custom style" },
    { name: "Adwaita", description: "GNOME Adwaita style" },
    { name: "Adwaita-Dark", description: "GNOME Adwaita dark style" }
  ]

  // Ready state
  property bool ready: false

  // Process for reading files (needs output)
  Process {
    id: fileReader
    running: false
    property var callback: null
    property var outputLines: []

    stdout: SplitParser {
      id: fileReaderCollector
      onRead: data => {
        if (data) {
          fileReader.outputLines.push(data)
        }
      }
    }

    onExited: (exitCode, exitStatus) => {
      if (fileReader.callback) {
        let fullOutput = fileReader.outputLines.join("\n")
        fileReader.callback(fullOutput)
        fileReader.callback = null
        fileReader.outputLines = []
      }
    }
  }

  Component.onCompleted: {
    Logger.i("QtStyleService", "Initializing Qt style service...")
    detectQtStyles()
    ready = true
    Logger.i("QtStyleService", `Found ${availableQtStyles.count} Qt styles`)
  }

  // Detect available Qt styles
  function detectQtStyles() {
    availableQtStyles.clear()

    // Add common styles to the list
    for (let style of commonStyles) {
      availableQtStyles.append({
        key: style.name,
        name: style.name,
        displayName: style.name,
        description: style.description
      })
    }

    // Note: Plugin detection would require async operations,
    // so we're keeping it simple with common styles for now
  }

  // Apply Qt style to all supported applications
  function applyQtStyle(styleName) {
    if (!styleName) {
      Logger.w("QtStyleService", "No style name provided")
      return false
    }

    Logger.i("QtStyleService", `Applying Qt style: ${styleName}`)

    // Update settings (auto-saves after 1 second)
    Settings.data.appearance.qtStyle = styleName

    // Apply to Qt5
    applyQt5Style(styleName)

    // Apply to Qt6
    applyQt6Style(styleName)

    // Set environment variables (note: only affects new processes)
    setEnvironmentVariables(styleName)

    currentQtStyle = styleName
    Logger.i("QtStyleService", "Qt style applied successfully")
    return true
  }

  // Apply style to Qt5 applications
  function applyQt5Style(styleName) {
    let configDir = Quickshell.env("HOME") + "/.config/qt5ct"
    let configFile = configDir + "/qt5ct.conf"

    // Ensure directory exists
    Quickshell.execDetached(["mkdir", "-p", configDir])

    // Read and update config
    readAndUpdateConfig(configFile, "style", styleName, "[Appearance]")
  }

  // Apply style to Qt6 applications
  function applyQt6Style(styleName) {
    let configDir = Quickshell.env("HOME") + "/.config/qt6ct"
    let configFile = configDir + "/qt6ct.conf"

    // Ensure directory exists
    Quickshell.execDetached(["mkdir", "-p", configDir])

    // Read and update config
    readAndUpdateConfig(configFile, "style", styleName, "[Appearance]")
  }

  // Set environment variables for Qt style
  function setEnvironmentVariables(styleName) {
    // Note: This only affects child processes launched after this point
    // The current shell session won't be affected
    // Users should add these to their shell profile for system-wide effect

    // Create/update environment file that can be sourced
    let envFile = Quickshell.env("HOME") + "/.config/noctalia/qt-env.sh"
    let envContent = `#!/bin/sh
# Auto-generated by Noctalia Shell - Qt Style Configuration
export QT_STYLE_OVERRIDE="${styleName}"
export QT_QPA_PLATFORMTHEME="qt5ct"
`

    Quickshell.execDetached(["mkdir", "-p", Quickshell.env("HOME") + "/.config/noctalia"])

    // Write environment file
    let qml = `
      import QtQuick
      import Quickshell.Io
      Process {
        running: true
        command: ["sh", "-c", "cat > '${envFile}'"]
        property string data: \`${envContent.replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`
        Component.onCompleted: {
          stdin = data
        }
        onExited: destroy()
      }
    `
    Qt.createQmlObject(qml, root, "envWriter")

    Logger.i("QtStyleService", `Environment variables written to ${envFile}`)
    Logger.i("QtStyleService", "Note: Restart applications or source the file for changes to take effect")
  }

  // Helper to read config file and update a setting
  function readAndUpdateConfig(filePath, key, value, section) {
    fileReader.callback = function(content) {
      // Update or add setting
      // Handle empty content (file doesn't exist or is empty)
      let lines = content && content.trim() !== "" ? content.split("\n") : []
      let updated = false
      let inSection = false

      for (let i = 0; i < lines.length; i++) {
        if (lines[i].trim() === section) {
          inSection = true
        } else if (lines[i].trim().startsWith("[")) {
          inSection = false
        }

        if (inSection && lines[i].startsWith(key + "=")) {
          lines[i] = `${key}=${value}`
          updated = true
        }
      }

      // If not found, add it
      if (!updated) {
        if (lines.length === 0 || !lines.some(l => l.trim() === section)) {
          // Add section if it doesn't exist
          lines.push(section)
        }
        // Find section and add after it
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].trim() === section) {
            lines.splice(i + 1, 0, `${key}=${value}`)
            break
          }
        }
      }

      // Write back
      writeFile(filePath, lines.join("\n"))
    }

    // Use 'cat' with error suppression - if file doesn't exist, callback gets empty string
    fileReader.command = ["sh", "-c", `cat "${filePath}" 2>/dev/null || true`]
    fileReader.running = true
  }

  // Helper to write file
  function writeFile(filePath, content) {
    let qml = `
      import QtQuick
      import Quickshell.Io
      Process {
        running: true
        command: ["sh", "-c", "cat > '${filePath}'"]
        property string data: \`${content.replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`
        Component.onCompleted: {
          stdin = data
        }
        onExited: destroy()
      }
    `
    Qt.createQmlObject(qml, root, "fileWriter")
  }
}
